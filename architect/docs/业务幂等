高可用的设计手段：
1.服务冗余：无状态化
2.幂等设计：负载均衡，ABA问题
3.超时机制：异步化设计
4.数据复制，缓存，Sharding:服务限流降级熔断
5.架构拆分，服务治理


服务幂等只需要在数据访问层实现：how?

请求幂等:同一个req
业务幂等:不同的请求,分布式锁

数据库的唯一索引
并发变串行，防止插入相同数据（本质上可以通过分布式锁解决)
找到共享资源，对共享资源加锁（和多线程相同哦）

CAP原理
分布式系统中要同时满足2者

分布式锁是CP模型
Redis是AP模型


金融行业 需要CP模型
SNS行业 需要AP模型

Redis中的LUA伪事务(已过时)：
MULTI;
XX;
XX;
EXEC;


推荐用法：set key value NX PX milliseconds;

如何设计一个分布式锁：
分布式锁一般基于etcd实现（k8s中默认用的etcd存储）
以sdk方式 嵌入到 微服务中

设计目标：
1. 强一致
2. 高可用
3.业务可重入
4. 可监控，管理
5.高度抽象业务，极简接入

分布式锁之ACS



==============
分布式事务（长事务）（分库的情况）
本地事务（短事务）
主体思想：把长事务拆成短事务，再进行协调。。

不建议用分布式事务， 主要是为了解决数据一致性CP



基于分布式事务解决数据库一致性：
强一致性事务：XA模型(刚性事务)：2pc, 3pc 
柔性事务：理论->CAP+BASE  方案->TCC,Saga,异步消息

TCC模型；
Saga模型：
	Saga隔离性
	恢复方式：向后恢复（多数情况选用），向前恢复
Sagas论文

tx-lcn模型：



处理各种状态的脚本。。。




