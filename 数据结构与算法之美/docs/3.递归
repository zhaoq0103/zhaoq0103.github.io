递归
我们的推荐人是如何递归的？（树形控件的展示问题，WEB页，NativeApp）
5.1 递归代码要警惕堆栈溢出
5.2递归代码要警惕重复计算

可以用递归处理的问题：
1.一个问题的解可以分解为几个子问题的解
2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3.存在递归终止条件
关键：
a.递归公式 b.终止条件
用递归程序来实现利率的计算

递归中“环”问题的解决:没看明白
////////
判断环的思路,使用链表:判断是否有环:使用步长法判断: 思路,从起点开始分别以2x,1x速度出发两个指针,当遇到null停止,相遇点为null时说明没有环,如果相遇点不为null,说明有环,注意有两个地方:
1.首次相遇点速度为1的指针是进入环的第一圈,切记切记
      证明一下呗: 设 圆环总长为: R , 指针分别设置为 1, 2吧,当1指针首次进入圆环交点时,2指针在圆环位置为 x ,则 2->1 步长为 (R - x)
      此时开始走i步以后相遇则: (R - x) + i = 2i; (原来相距位置加上1走的距离等于 2倍的1走距离)
      则 i = R - x ; (X <= R) 的,所以 i < R (肯定在第一圈相遇)
     由上可得:
      在第一圈相遇的时候1走的距离为: 设 起始点至环入口位置为 L ,则 1路程为(L + i)
      2走的距离为 (L + nR + i) ,n为圈数
      则: (L + nR + i) = 2(L + i); (切记:n >= 1 -> 2比1先进圈)(2速度为1的2倍,1的总路程 * 2)
      即: L = nR - i = (n - 1)R + (R - i) ; (n >= 1) 我们不管(n - 1)R,只是简单的绕圈数
      所以 L = R - i ; 而首次进入圈相遇的位置为 i ,整个圈长为 R ,
      所以当首次相遇的时候,重新以1为步长,一个以相交点为起始,一个以首节点开始,首次相遇点即为环的起始点;
/////
